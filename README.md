# C_primier_Plus
 - to_string 是用于将数字转换成字符
 - stio是将字符串转换为数字
 - isdigit 是用于判断字符串中的字符是否属于数字
 - vector + vector是用insert进行操作的
 - 字符串也可以使用find，可以用于找子串，但是效率不如KMP算法
 - vector<pair<int,int>> pairs

- 对待哈希冲突一般是链式寻址（value改成链表形式）和开放寻址（自动填充到下一个空位），哈希冲突一般是0.75达到阈值

- struct结构体中所有的变量都会统一内存对齐（每个变量分配的内存是该变量的整数倍，结构体的大小最后是变量类型最大值的整数倍），alignas会将整个结构体的最小对齐单位给初始化，但是如果结构体内有变量大于该约束，则约束失效。不是对齐到“最大值”，而是对齐到“自己类型的对齐值整数倍地址”

- 指针可以指向nullptr，但是引用必须指向具体数，且引用的底层也是指针实现的。指针用完之后一定要释放，指针定义后可以改变指向，但是引用不能改变。对于函数来说，一般使用引用才能改变值，否则传入的只是值的副本。引用和指针一样都是占用内存的，而且占用的内存一样大

- 函数的局部变量是存储在栈区的，后来先释放，这个是系统所决定是否释放，然而如果是堆，则是根据程序员本身所决定是否释放，本质都是系统内存的使用。堆向上是高地址增长，栈向下是高地址增长

- new/delete 是安全的C++运算符，malloc/free是C的函数，前者是安全的，后者是需要程序员自己操作定义的，前者会调用析构函数进行初始化，后者不会调用。前者返回的是定义好的指针，后者是一个待定义的void指针，因此需要另外指定类型。new不需要自己计算内存大小，malloc需要自己计算内存大小
  
- 宏定义本质就是文本替换，在预处理的时候就已经完成了文本替换，宏定义不会进行类型检查，但是函数（编译阶段）在会进行返回值的检查；tepedef（编译阶段）主要是定义类别的别名，会进行类型检查，增强代码的可读性。预处理 → 编译 → 汇编 → 连接 → 运行

- strlen不包括\0的长度，并且是在程序运行的时候进行计算，而sizeof是在编译的时候进行计算

- 指针常量const int * p是说指针所指的是常量，其值不能修改，但是指针所指的地址可以修改。常量指针int * const p是说指针不可修改

- struct是C语言中的，Class是C++中的。struct的默认属性是公有，class默认属性是私有。struct默认public继承，class默认是private继承。public继承后的属性就变成了public，private继承后的属性就是private，不管什么继承都不能访问private

- static的局部变量不会在函数结束的时候销毁，会在程序运行结束后的时候销毁，不会存在栈，而是存在程序运行的数据段。静态全局变量的话会使得只能在文件内使用，可以跨文件可见，通过extern。静态成员变量需要在对象外面定义，类声明仅声明其存在

- 对于虚函数而言，override代表了类就是继承基类的函数，如果函数名写错了那就会报错。final代表了这个类是继承基类的最后的类，再来一次就报错。虚函数存在的意义就是C++中的多态，虚函数是在运行时决定使用函数的哪个版本，允许一个虚函数被多次重写

- 拷贝初始化会创建临时对象，然后通过拷贝构造函数初始化至目标对象中；直接初始化就是直接调用最匹配的函数进行构造。拷贝初始化会使得代码行文更加简单，但是可能会有涉及到隐式转换，而直接初始化就是行文麻烦，不涉及转换

- register关键字变量是寄存器变量，代表了变量在寄存器中，虽然速度快但是不能使用取地址，因为寄存器内没有内存地址

- 野指针--指向一块随机的、不可预测的内存地址的指针（会访问失败）  悬垂指针--指针曾经指向某个合法对象，但该对象已经销毁或释放，指针仍旧持有原地址（不会访问失败，是nullptr）（比如堆的释放之后仍然使用该指针，这就会出现悬垂指针），用share可以解决

- 函数重载是同一个水平方向方面--同一函数名不同返回值。函数重写只能是对于父类和子类，且重写必须是对虚函数进行重写。隐藏是父类的函数不是虚函数。重载（静态的多态)是编译时进行，重写(动态的多态））是运行时进行。

- 默认构造函数：无参数或所有参数有默认值的构造函数；带参数的构造函数：通过参数初始化对象的构造函数；拷贝构造函数：通过另一个对象初始化当前对象；移动构造函数：通过“移动”另一个对象的资源初始化当前对象，避免不必要的内存复制；委托构造函数：一个构造函数调用另一个构造函数，避免代码重复；显式构造函数：禁止编译器进行隐式类型转换。

- 浅拷贝只复制对象本身，只是复制了地址，嵌套对象的引用仍然指向于原始对象。深层拷贝不只是复制对象本身，它会开辟新的内存用于存储，还递归复制了全部引用。当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，从而导致指针悬挂现象，所以，此时，必须采用深拷贝

- 内联函数的关键词是inline，会在编译的时候嵌入到调用函数的地方，具有类型检查，但是如果内联函数较大，会导致代码膨胀（编译期）

- 在类中public > protected > private ，继承方式与继承成员会取最小的

- volatile表示了该变量可能被外界所改变。mutable代表了即使设置为const也能改变其值。explicit表示对象不能进行类型的隐式转换

- new用于动态分配内存，不同于栈在编译的时候分配，new是在运行的时候分配内存，且会存在堆上，然后需要使用delete进行释放、C++中有plain new， nothrow new 和placcement new

- 类中的static函数没有this指针，因此不能访问非static成员

- 形参是在函数被调用的时候才会分配内存单元，只能实参传递给形参，不能反过来

- 值传递是传递的副本，不改变值本身。指针传递传递的是地址，其值会改变。引用传递也会改变值

- 对象复用就是将对象复制进池子中（放回池子之前必须重置对象状态（避免脏数据）），再次调用的时候就不需要malloc。零拷贝就是避免内存拷贝以提高效率，不是完全的零拷贝，可能还是有一些fd拷贝了。

- 初始化列表会在类初始化的时候直接进行赋值，但如果是函数体中赋值则会多一次析构函数的调用

- 移动构造函数是指利用对象a生成对象b的时候，若a已经没用了，那就直接利用a的内存，这样就能避免利用新的空间（它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是"拿"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr）

- C++ 中的返回值一般会放在寄存器中，而不是堆或者栈，因为函数结束后堆和栈的内存都会被释放

- 全局变量存储在程序的数据区，而局部变量存储在栈区，只有malloc或者new在堆区。

- 向上转换可以自动进行--派生类到基类  向下转换不能自动进行--基类到派生类

- 组合是在类中使用之前的类，属于has a 。 继承是继承父类，属于is a

- 函数指针就是指向函数的指针，调用这个指针就是启动这个函数，主要是服务于多态

- 使用模板可以提升代码的泛化能力，且模板放在h文件中能给编译器在编译的时候就已知

- 静态变量主要其作用域比较独特，一般存在数据区，全局变量也一般存在数据区，而普通变量（局部变量在栈区）则在对象结束后即释放
   
- volatile表示编译器不需要对其进行优化，每次用的时候都重新在内存中读取

- 回调函数的本质就是将一个函数传递给另外一个函数

- 友元函数可以访问类的protected

- 内存一般分为五个区：堆，栈，常量区，自由存储区和静态存储区

- 预处理是不做类型检查的，编译才会做类型检查

- 在使用继承的时候，析构函数一定要定义为虚函数，否则不会被调用从而导致内存泄漏

- map的底层是红黑树，其插入和删除都是logn，而unordered_map的底层是哈希表。追求稳定一般选择map，另一个可能产生rehash使得复杂度变成n，

- STL中有顺序容器，无序容器，关联容器，容器适配器，其他容器等

- 智能指针是一种动态管理内存的机制，主要有unique（独占，不允许复制，自动释放内存）， share（共享，所有结束才释放内存） 和 weak（不参与计数）                  

- 静态联编是在编译时编译器就能完全确定函数的调用，而动态联编是需要程序在运行时才能确定，依赖虚函数的机制

- 类型转换分为显式转换和隐式转换。隐式转换大多是数值类型的转换，其可能存在精度丢失，大数吃小数的问题。显式转换一般由程序员手动实现，主要有四种类型转换分别是static_cast（用于已知的安全的转换），dynamic_cast（动态转换，类向上向下转换，会进行安全检测），const_cast(去除const/volatile修饰)

- 预处理、编译、汇编、链接、加载、运行

- qt本质就是信号与槽，Qt有三大核心机制--元对象系统（Qobject），属性系统和信号与槽slot。对象皆可发出信号，根据信号触发槽

- 所有的事件都继承QEvent，所有的对象都继承Qobject

- 信号与槽式Qt对象之间通信的机制，当某个对象的状态发生变化时，它会发出一个信号，其他对象可以通过槽来接收信号并做出反应

- Qt中是主事件进行循环，自定义事件通过event进行处理

- 单例主要是为了一个类只能创建一个实例化，直接将构造函数和析构函数设置为private即可，同时禁止拷贝和复制

- 虚函数表就是一个存放虚函数指针的指针数组，每个虚函数都有虚函数表，指向虚函数的指针为vptr

- 缓存穿透--查询一个不存在的数据，每次请求都会去DB查找。可以缓存空对象
  缓存雪崩--缓存中的大量数据在同一时刻过期。随机刷新缓存的时间，或者使用双缓存机制
  缓存击穿--同时请求。加锁

- 如何解决高并发下的缓存优化--缓存分片、读写分离（share_mutex）

- static在类中的静态函数只能访问静态的值，不能访问非静态的。静态成员变量必须在类外面先定义，以便其分配空间

- 内存分为栈、堆、静态区、常量区、代码区，当然这都是用户空间，内核空间是单独的

- 结构体的大小是所有成员之和，可以同时访问所有成员；而联合体大小是最大成员大小，只能同时访问一个成员，是互斥的，主要为了节省内存

- 实现单例--私有化构造函数，静态成员变量，静态全局访问点

- 若继承有多层，类似于菱形继承，那么可以使用virtual继承，那么直接调用底层的进行继承

- 静态成员函数--属于对象而不是属于类，因此可以直接使用类名进行调用，而不是需要先定义对象，他不能访问非静态的成员，因为不含有this指针。静态成员变量--所有的对象共享一个静态成员变量，一般用于计算对象的个数，属于类

- STL包含容器（vector..）、算法(sort..)、迭代器(begin..)、仿函数(f(x)..)、空间支配器(allocator..)

- this指针是类中的隐式指针，每当要访问当前对象中的成员函数的时候，this指针都会指向该地址

- 类就是一种模板，对象是类的实例
<img width="227" height="418" alt="image" src="https://github.com/user-attachments/assets/20dbc89c-5487-4805-9387-a01992857f68" />

- push_back--复制一个元素加入  emplace_back--直接构造函数在末尾

- 左值是有连续的存储的（int x = 1），右值（移动语义和完美转发）是临时的、没有持久性的对象，通常代表某些临时计算结果或常量。右值没有固定的内存地址，并且不可以通过 & 运算符取其地址。（x + 1）。左值引用就是指向左值的引用，一般是传入地址，右值引用主要是用于移动资源，可以避免不必要的内存复制，因此可以用于移动构造函数，避免了内存复制  。 一般是使用&&进行右值引用，然后就利用移动拷贝偷走资源，但是不是所有的都能被偷，因此需要使用move（必须有定义移动构造函数，否则就是普通的拷贝）进行右值转换
MyString s1("Hello");
MyString&& s2 = std::move(s1);  // 正确：通过 std::move 将左值转换为右值引用


- 源代码编写：你用高级编程语言（比如 C、C++、Java、Python 等）编写源代码。
编译：编译器将源代码转化为中间代码（如字节码或汇编语言）。编译器会根据目标平台的处理器架构（即指令集）生成适合该平台的机器指令。
  如果你在一个基于 x86 的系统上编译，编译器会生成符合 x86 指令集的代码。
  如果你在一个基于 ARM 的系统上编译，编译器会生成符合 ARM 指令集的代码。
汇编与链接：编译生成的中间代码（如汇编语言）会通过汇编器转换成机器代码（二进制代码），这时的代码就完全是基于特定指令集的机器指令了。
执行：最终的机器代码会被加载到内存中，CPU 根据机器指令执行这些操作。每条机器指令都是处理器能够识别的指令集中的一个指令。

- 协程是在用户态下面的异步，主要是以异步io为主，在主线程进行其他的时候可以异步下载，协程设计的多了也会有切换上下文过度的问题。协程的使用需要将传统的同步代码改为异步代码，使用async和await关键字。

- 内存池的核心思想是：预先申请一块大块的内存，随后在这块内存中划分出多个小块，用于动态分配给不同的对象。当对象不再需要时，它们不会被直接销毁，而是通过内存池来进行“复用”，从而降低了频繁申请和释放内存的性能成本。

- 闭包的本质是：函数可以捕获它所在环境的变量，并且这些变量会随着函数一起“携带”到函数外部，使得即使在函数执行的环境已经不存在的情况下，闭包仍然可以访问这些变量。可以分为按值捕获和按引用捕获，就是将变量保存至函数可以使得函数独立。使用闭包来捕获当前的计数状态，可以确保每个回调函数独立地管理自己的计数，避免竞态条件和计数混乱。需要全局计数 → 用 锁/原子变量；需要每个回调独立计数 → 用 闭包 + 非共享变量；需要每线程独立计数 → 用 threading.local

- 信号量本质上是一个由操作系统管理的内核对象，用于控制多个进程或线程对共享资源的访问。它通常表现为一个计数器，但不仅仅是一个简单的共享内存变量。信号量的实现依赖于原子操作，确保在多进程或线程环境下计数器的值能够正确地递增和递减，从而避免竞态条件和资源争用问题；信号量可以分为两种类型：二进制信号量和计数信号量。二进制信号量只能取0或1，通常用于互斥，而计数信号量可以取更大的值，用于控制对多个资源的访问。

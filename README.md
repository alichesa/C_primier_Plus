# C_primier_Plus
  # **哈希表**
 - find是寻找key，而不是寻找value <key, value>
 - 哈希表的查询是1的原因是它利用了数组的特性，其本质就是由数组构成的，将key转换成值，然后与地址挂钩
 - 哈希表的冲突可以扩容，扩容不人为定义，会自动设置阈值，例如.75
 - 官方对待哈希冲突一般是链式寻址（value改成链表形式）和开放寻址（自动填充到下一个空位）
 - 哈希使用find是寻找出值，不能用if直接判断是0/1(!=nullptr)，应该是!=  .end()

 # **指针与取址**
 - * 是定义为指针  &是取址

 # **数组与链表**
 - 链表的创建是new Listnode()实现，如果只是Listnode * 那并没有创建，访问val和next会显示段错误
 - 链表是基础，然后构成树那些
 - 链表一般是先定义一个dummy，然后再first second，如果你改变了位置，那么first 和second也会改变位置
 - 链表中 first -> next = ...  这只是改变first后面的值，但是first是不变的，又或者说此时链表是不变的，first = first -> next 这才是移动

 # **栈、队列和列表**
- 栈push()、pop()、peek()、top()，可用链表和数组实现 stack
- 队列和栈一样 queue
- 列表的本质是动态数组，因此可以不赋予初始值
- queue是单向队列，deque是双向队列

 # **树**
- 树和链表一样，必须得新建一个节点然后再指向，那么才能使用val和next
- 完美二叉树（满二叉树）-所有层节点都填满
- 完全二叉树- 仅最底层的没填满，同时最底层靠左填充
- 平衡二叉树-左子树的高度与右子树的高度差绝对值小于1
- 广度优先搜索（先上再下，同时先左后右）
-  二叉搜索树是一个极其规则的树，对于数值大小排列来说

 # **分治**
 - 分而治之，然后合并返回
 - 问题可以分解、子问题独立、子问题合并（可/无须）

 # **排序**
 - 数量多的话用快速排序（有哨兵），数量不多一般是直接用插入

 # **堆**
 - 堆的本质是二叉树，其分为小顶堆和大顶堆，但是初始化方法完全不一样！

 # **图**
 - 图是由V和E构成G，V是节点，E是边
 - 图可以由领接矩阵和领接链表构成

 # **Skills**
 - to_string 是用于将数字转换成字符
 - stio是将字符串转换为数字
 - isdigit 是用于判断字符串中的字符是否属于数字
 - break 不只是挑出当前for，而是跳出所有for
 - vector + vector是用insert进行操作的
 - 字符串也可以使用find，可以用于找子串，但是效率不如KMP算法
 - vector<pair<int,int>> pairs 

- struct结构体中所有的变量都会统一内存对齐（每个变量分配的内存是该变量的整数倍，结构体的大小最后是变量类型最大值的整数倍），alignas会将整个结构体的最小对齐单位给初始化，但是如果结构体内有变量大于该约束，则约束失效。不是对齐到“最大值”，而是对齐到“自己类型的对齐值整数倍地址”

- 指针可以指向nullptr，但是引用必须指向具体数，且引用的底层也是指针实现的。指针用完之后一定要释放，指针定义后可以改变指向，但是引用不能改变。对于函数来说，一般使用引用才能改变值，否则传入的只是值的副本。引用和指针一样都是占用内存的，而且占用的内存一样大

- 函数的局部变量是存储在栈区的，后来先释放，这个是系统所决定是否释放，然而如果是堆，则是根据程序员本身所决定是否释放，本质都是系统内存的使用。堆向上是高地址增长，栈向下是高地址增长

- new/delete 是安全的C++运算符，malloc/free是C的函数，前者是安全的，后者是需要程序员自己操作定义的，前者会调用析构函数进行初始化，后者不会调用。前者返回的是定义好的指针，后者是一个待定义的void指针，因此需要另外指定类型。new不需要自己计算内存大小，malloc需要自己计算内存大小

- 宏定义本质就是文本替换，在编译的时候就已经完成了文本替换，宏定义不会进行类型检查，但是函数会进行返回值的检查

- tepedef主要是定义类别的别名，会进行类型检查，增强代码的可读性

- strlen不包括\0的长度，并且是在程序运行的时候进行计算，而sizeof是在编译的时候进行计算

- 指针常量const int * p是说指针所指的是常量，其值不能修改，但是指针所指的地址可以修改。常量指针int * const p是说指针不可修改

- struct是C语言中的，Class是C++中的。struct的默认属性是公有，class默认属性是私有。struct默认public继承，class默认是private继承

- static的局部变量不会在函数结束的时候销毁，静态全局变量的话会使得只能在文件内使用，静态成员变量需要在对象外面定义。const就是一个常量定义

- 对于虚函数而言，override代表了类就是继承基类的函数，如果函数名写错了那就会报错。final代表了这个类是继承基类的最后的类，再来一次就报错。虚函数存在的意义就是C++中的多态，虚函数是在运行时决定使用函数的哪个版本，允许一个虚函数被多次重写

- 拷贝初始化会创建临时对象，然后通过拷贝构造函数初始化至目标对象中，直接初始化就是进行赋值

- 野指针强调内存已经被释放或者回收（或者说一开始就是指向的是nullptr），悬空指针指的是对象已经被销毁或者生命周期已经结束

- 函数重载是同一个水平方向方面--同一函数名不同返回值。函数重写只能是对于父类和子类，且重写必须是对虚函数进行重写。隐藏是父类的函数不是虚函数。重载是编译时进行，重写是运行时进行。

- 浅拷贝只复制对象本身，只是复制了地址，嵌套对象的引用仍然指向于原始对象。深层拷贝不只是复制对象本身，它会开辟新的内存用于存储，还递归复制了全部引用

- 内联函数的关键词是inline，会在编译的时候嵌入到调用函数的地方，具有类型检查，但是如果内联函数较大，会导致代码膨胀

- 在类中public > protected > private ，继承方式与继承成员会取最小的

- volatile表示了该变量可能被外界所改变。mutable代表了即使设置为const也能改变其值。explicit表示对象不能进行类型的隐式转换

- new用于动态分配内存，不同于栈在编译的时候分配，new是在运行的时候分配内存，且会存在堆上，然后需要使用delete进行释放、C++中有plain new， nothrow new 和placcement new

- 类中的static函数没有this指针，因此不能访问非static成员

- 形参是在函数被调用的时候才会分配内存单元，只能实参传递给形参，不能反过来

- 值传递是传递的副本，不改变值本身。指针传递传递的是地址，其值会改变。引用传递也会改变值

- 对象复用就是将对象复制进池子中，再次调用的时候就不需要malloc。零拷贝就是避免内存拷贝以提高效率。

- 初始化列表会在类初始化的时候直接进行赋值，但如果是函数体中赋值则会多一次析构函数的调用

- 移动构造函数是指利用对象a生成对象b的时候，若a已经没用了，那就直接利用a的内存，这样就能避免利用新的空间

- C++ 中的返回值一般会放在寄存器中，而不是堆或者栈，因为函数结束后堆和栈的内存都会被释放

- 全局变量存储在程序的数据区，而局部变量存储在栈区，只有malloc或者new在堆区。

- 向上转换可以自动进行--派生类到基类  向下转换不能自动进行--基类到派生类

- 组合是在类中使用之前的类，属于has a 。 继承是继承父类，属于is a

- 函数指针就是指向函数的指针，调用这个指针就是启动这个函数，主要是服务于多态

- 使用模板可以提升代码的泛化能力，且模板放在h文件中能给编译器在编译的时候就已知

- 静态变量主要其作用域比较独特，一般存在数据区，但是全局变量则一般存在数据区，而普通变量则在对象结束后即释放
   
- volatile表示编译器不需要对其进行优化，每次用的时候都重新在内存中读取

- 回调函数的本质就是将一个函数传递给另外一个函数

- 友元函数可以访问类的protected

- 内存一般分为五个区：堆，栈，常量区，自由存储区和静态存储区

- 预处理是不做类型检查的，编译才会做类型检查

- 在使用继承的时候，析构函数一定要定义为虚函数，否则不会被调用从而导致内存泄漏

- map的底层是红黑树，其插入和删除都是logn，而unordered_map的底层是哈希表。追求稳定一般选择map，另一个可能产生rehash使得复杂度变成n，

- STL中有顺序容器，无序容器，关联容器，容器适配器，其他容器等

- 智能指针是一种动态管理内存的机制，主要有unique（独占，不允许复制，自动释放内存）， share（共享，所有结束才释放内存） 和 weak（不参与计数）                  

- 静态联编是在编译时编译器就能完全确定函数的调用，而动态联编是需要程序在运行时才能确定，依赖虚函数的机制

- 类型转换分为显式转换和隐式转换。隐式转换大多是数值类型的转换，其可能存在精度丢失，大数吃小数的问题。显式转换一般由程序员手动实现，主要有四种类型转换分别是static_cast（用于已知的安全的转换），dynamic_cast（动态转换，类向上向下转换，会进行安全检测），const_cast(去除const/volatile修饰)

- 预处理、编译、汇编、链接、加载、运行

- qt本质就是信号与槽，Qt有三大核心机制--元对象系统（Qobject），属性系统和信号与槽slot。对象皆可发出信号，根据信号触发槽

- 所有的事件都继承QEvent，所有的对象都继承Qobject

- 信号与槽式Qt对象之间通信的机制，当某个对象的状态发生变化时，它会发出一个信号，其他对象可以通过槽来接收信号并做出反应

- Qt中是主事件进行循环，自定义事件通过event进行处理

- 单例主要是为了一个类只能创建一个实例化，直接将构造函数和析构函数设置为private即可，同时禁止拷贝和复制

- 虚函数表就是一个存放虚函数指针的指针数组，每个虚函数都有虚函数表，指向虚函数的指针为vptr

- 缓存穿透--查询一个不存在的数据，每次请求都会去DB查找。可以缓存空对象
  缓存雪崩--缓存中的大量数据在同一时刻过期。随机刷新缓存的时间，或者使用双缓存机制
  缓存击穿--同时请求。加锁

- 如何解决高并发下的缓存优化--缓存分片、读写分离（share_mutex）

- static在类中的静态函数只能访问静态的值，不能访问非静态的。静态成员变量必须在类外面先定义，以便其分配空间

- 内存分为栈、堆、静态区、常量区、代码区

- 代码运行--编译期（将源代码转换成机器语言）→ 预处理期（处理一些宏定义以及include） → 链接期（动态链接和静态链接） → 运行期
